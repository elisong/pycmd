# -*- coding: utf-8 -*-
# Description:  HiveQL Keywords Formatter
# Usage: hiveql [-h] [-i] [-r RESERVE] file
import argparse
import re
from pathlib import Path

from .utils import Console


parser = argparse.ArgumentParser(prog="hiveql", description="HiveQL Keywords Formatter")
parser.add_argument("-i", "--inplace", action="store_true", help="format inplace")
parser.add_argument("-r", "--reserve", type=str, help="patterns reserved, comma seporated")
parser.add_argument("file", type=str, help="source file")
args = parser.parse_args()

RESERVED_KWS = [
    "ALL",
    "ALTER",
    "AND",
    "ARRAY",
    "AS",
    "AUTHORIZATION",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BOOLEAN",
    "BOTH",
    "BY",
    "CASE",
    "CAST",
    "CHAR",
    "COLUMN",
    "CONF",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_TIMESTAMP",
    "CURSOR",
    "DATABASE",
    "DATE",
    "DECIMAL",
    "DELETE",
    "DESCRIBE",
    "DISTINCT",
    "DOUBLE",
    "DROP",
    "ELSE",
    "END",
    "EXCHANGE",
    "EXISTS",
    "EXTENDED",
    "EXTERNAL",
    "FALSE",
    "FETCH",
    "FLOAT",
    "FOLLOWING",
    "FOR",
    "FROM",
    "FULL",
    "FUNCTION",
    "GRANT",
    "GROUP",
    "GROUPING",
    "HAVING",
    "IF",
    "IMPORT",
    "IN",
    "INNER",
    "INSERT",
    "INT",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "JOIN",
    "LATERAL",
    "LEFT",
    "LESS",
    "LIKE",
    "LOCAL",
    "MACRO",
    "MAP",
    "MORE",
    "NONE",
    "NOT",
    "NULL",
    "OF",
    "ON",
    "OR",
    "ORDER",
    "OUT",
    "OUTER",
    "OVER",
    "PARTIALSCAN",
    "PARTITION",
    "PERCENT",
    "PRECEDING",
    "PRESERVE",
    "PROCEDURE",
    "RANGE",
    "READS",
    "REDUCE",
    "REVOKE",
    "RIGHT",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SELECT",
    "SET",
    "SMALLINT",
    "TABLE",
    "TABLESAMPLE",
    "THEN",
    "TIMESTAMP",
    "TO",
    "TRANSFORM",
    "TRIGGER",
    "TRUE",
    "TRUNCATE",
    "UNBOUNDED",
    "UNION",
    "UNIQUEJOIN",
    "UPDATE",
    "USER",
    "USING",
    "UTC_TMESTAMP",
    "VALUES",
    "VARCHAR",
    "WHEN",
    "WHERE",
    "WINDOW",
    "WITH",
    "COMMIT",
    "ONLY",
    "REGEXP",
    "RLIKE",
    "ROLLBACK",
    "START",
    "CACHE",
    "CONSTRAINT",
    "FOREIGN",
    "PRIMARY",
    "REFERENCES",
    "DAYOFWEEK",
    "EXTRACT",
    "FLOOR",
    "INTEGER",
    "PRECISION",
    "VIEWS",
    "TIME",
    "NUMERIC",
    "SYNC",
]

NON_RESERVED_KWS = [
    "ADD",
    "ADMIN",
    "AFTER",
    "ANALYZE",
    "ARCHIVE",
    "ASC",
    "BEFORE",
    "BUCKET",
    "BUCKETS",
    "CASCADE",
    "CHANGE",
    "CLUSTER",
    "CLUSTERED",
    "CLUSTERSTATUS",
    "COLLECTION",
    "COLUMNS",
    "COMMENT",
    "COMPACT",
    "COMPACTIONS",
    "COMPUTE",
    "CONCATENATE",
    "CONTINUE",
    "DATA",
    "DATABASES",
    "DATETIME",
    "DAY",
    "DBPROPERTIES",
    "DEFERRED",
    "DEFINED",
    "DELIMITED",
    "DEPENDENCY",
    "DESC",
    "DIRECTORIES",
    "DIRECTORY",
    "DISABLE",
    "DISTRIBUTE",
    "ELEM_TYPE",
    "ENABLE",
    "ESCAPED",
    "EXCLUSIVE",
    "EXPLAIN",
    "EXPORT",
    "FIELDS",
    "FILE",
    "FILEFORMAT",
    "FIRST",
    "FORMAT",
    "FORMATTED",
    "FUNCTIONS",
    "HOLD_DDLTIME",
    "HOUR",
    "IDXPROPERTIES",
    "IGNORE",
    "INDEX",
    "INDEXES",
    "INPATH",
    "INPUTDRIVER",
    "INPUTFORMAT",
    "ITEMS",
    "JAR",
    "KEYS",
    "KEY_TYPE",
    "LIMIT",
    "LINES",
    "LOAD",
    "LOCATION",
    "LOCK",
    "LOCKS",
    "LOGICAL",
    "LONG",
    "MAPJOIN",
    "MATERIALIZED",
    "METADATA",
    "MINUS",
    "MINUTE",
    "MONTH",
    "MSCK",
    "NOSCAN",
    "NO_DROP",
    "OFFLINE",
    "OPTION",
    "OUTPUTDRIVER",
    "OUTPUTFORMAT",
    "OVERWRITE",
    "OWNER",
    "PARTITIONED",
    "PARTITIONS",
    "PLUS",
    "PRETTY",
    "PRINCIPALS",
    "PROTECTION",
    "PURGE",
    "READ",
    "READONLY",
    "REBUILD",
    "RECORDREADER",
    "RECORDWRITER",
    # "REGEXP",
    "RELOAD",
    "RENAME",
    "REPAIR",
    "REPLACE",
    "REPLICATION",
    "RESTRICT",
    "REWRITE",
    # "RLIKE",
    "ROLE",
    "ROLES",
    "SCHEMA",
    "SCHEMAS",
    "SECOND",
    "SEMI",
    "SERDE",
    "SERDEPROPERTIES",
    "SERVER",
    "SETS",
    "SHARED",
    "SHOW",
    "SHOW_DATABASE",
    "SKEWED",
    "SORT",
    "SORTED",
    "SSL",
    "STATISTICS",
    "STORED",
    "STREAMTABLE",
    "STRING",
    "STRUCT",
    "TABLES",
    "TBLPROPERTIES",
    "TEMPORARY",
    "TERMINATED",
    "TINYINT",
    "TOUCH",
    "TRANSACTIONS",
    "UNARCHIVE",
    "UNDO",
    "UNIONTYPE",
    "UNLOCK",
    "UNSET",
    "UNSIGNED",
    "URI",
    "USE",
    "UTC",
    "UTCTIMESTAMP",
    "VALUE_TYPE",
    "VIEW",
    "WHILE",
    "YEAR",
    "AUTOCOMMIT",
    "ISOLATION",
    "LEVEL",
    "OFFSET",
    "SNAPSHOT",
    "TRANSACTION",
    "WORK",
    "WRITE",
    "ABORT",
    "KEY",
    "LAST",
    "NORELY",
    "NOVALIDATE",
    "NULLS",
    "RELY",
    "VALIDATE",
    "DETAIL",
    "DOW",
    "EXPRESSION",
    "OPERATOR",
    "QUARTER",
    "SUMMARY",
    "VECTORIZATION",
    "WEEK",
    "YEARS",
    "MONTHS",
    "WEEKS",
    "DAYS",
    "HOURS",
    "MINUTES",
    "SECONDS",
    "TIMESTAMPTZ",
    "ZONE",
]

BUILT_IN_FUNCTIONS = [
    "abs",
    "acos",
    "add_months",
    "aes_decrypt",
    "aes_encrypt",
    "and",
    "array",
    "array_contains",
    "ascii",
    "asin",
    "assert_true",
    "assert_true_oom",
    "atan",
    "avg",
    "base64",
    "between",
    "bin",
    "bloom_filter",
    "bround",
    "cardinality_violation",
    "case",
    "cbrt",
    "ceil",
    "ceiling",
    "char_length",
    "character_length",
    "chr",
    "coalesce",
    "collect_list",
    "collect_set",
    "compute_stats",
    "concat",
    "concat_ws",
    "context_ngrams",
    "conv",
    "corr",
    "cos",
    "count",
    "covar_pop",
    "covar_samp",
    "crc32",
    "create_union",
    "cume_dist",
    "current_authorizer",
    "current_database",
    "current_date",
    "current_groups",
    "current_timestamp",
    "current_user",
    "date_add",
    "date_format",
    "date_sub",
    "datediff",
    "day",
    "dayofmonth",
    "dayofweek",
    "decode",
    "degrees",
    "dense_rank",
    "div",
    "e",
    "elt",
    "encode",
    "enforce_constraint",
    "exp",
    "explode",
    "extract_union",
    "factorial",
    "field",
    "find_in_set",
    "first_value",
    "floor",
    "floor_day",
    "floor_hour",
    "floor_minute",
    "floor_month",
    "floor_quarter",
    "floor_second",
    "floor_week",
    "floor_year",
    "format_number",
    "from_unixtime",
    "from_utc_timestamp",
    "get_json_object",
    "get_splits",
    "greatest",
    "grouping",
    "hash",
    "hex",
    "histogram_numeric",
    "hour",
    "if",
    "in",
    "in_bloom_filter",
    "in_file",
    "index",
    "initcap",
    "inline",
    "instr",
    "internal_interval",
    "isfalse",
    "isnotfalse",
    "isnotnull",
    "isnottrue",
    "isnull",
    "istrue",
    "java_method",
    "json_tuple",
    "lag",
    "last_day",
    "last_value",
    "lcase",
    "lead",
    "least",
    "length",
    "levenshtein",
    "like",
    "likeall",
    "likeany",
    "ln",
    "locate",
    "log",
    "log10",
    "log2",
    "logged_in_user",
    "lower",
    "lpad",
    "ltrim",
    "map",
    "map_keys",
    "map_values",
    "mask",
    "mask_first_n",
    "mask_hash",
    "mask_last_n",
    "mask_show_first_n",
    "mask_show_last_n",
    "matchpath",
    "max",
    "md5",
    "min",
    "minute",
    "mod",
    "month",
    "months_between",
    "named_struct",
    "negative",
    "next_day",
    "ngrams",
    "noop",
    "noopstreaming",
    "noopwithmap",
    "noopwithmapstreaming",
    "not",
    "ntile",
    "nullif",
    "nvl",
    "octet_length",
    "or",
    "parse_url",
    "parse_url_tuple",
    "percent_rank",
    "percentile",
    "percentile_approx",
    "pi",
    "pmod",
    "posexplode",
    "positive",
    "pow",
    "power",
    "printf",
    "quarter",
    "radians",
    "rand",
    "rank",
    "reflect",
    "reflect2",
    "regexp",
    "regexp_extract",
    "regexp_replace",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "repeat",
    "replace",
    "replicate_rows",
    "restrict_information_schema",
    "reverse",
    "rlike",
    "round",
    "row_number",
    "rpad",
    "rtrim",
    "second",
    "sentences",
    "sha",
    "sha1",
    "sha2",
    "shiftleft",
    "shiftright",
    "shiftrightunsigned",
    "sign",
    "sin",
    "size",
    "sort_array",
    "sort_array_by",
    "soundex",
    "space",
    "split",
    "sq_count_check",
    "sqrt",
    "stack",
    "std",
    "stddev",
    "stddev_pop",
    "stddev_samp",
    "str_to_map",
    "struct",
    "substr",
    "substring",
    "substring_index",
    "sum",
    "tan",
    "to_date",
    "to_epoch_milli",
    "to_unix_timestamp",
    "to_utc_timestamp",
    "translate",
    "trim",
    "trunc",
    "ucase",
    "udftoboolean",
    "udftobyte",
    "udftodouble",
    "udftofloat",
    "udftointeger",
    "udftolong",
    "udftoshort",
    "udftostring",
    "unbase64",
    "unhex",
    "unix_timestamp",
    "upper",
    "uuid",
    "var_pop",
    "var_samp",
    "variance",
    "version",
    "weekofyear",
    "when",
    "width_bucket",
    "windowingtablefunction",
    "xpath",
    "xpath_boolean",
    "xpath_double",
    "xpath_float",
    "xpath_int",
    "xpath_long",
    "xpath_number",
    "xpath_short",
    "xpath_string",
    "year",
]


def substitute(content):
    keywords = BUILT_IN_FUNCTIONS + RESERVED_KWS + NON_RESERVED_KWS
    if args.reserve:
        keywords += args.reserve.split(",")

    # tricks while file's first/last word is keyword.
    content = " " + content + " "
    for kw in keywords:
        # overlapping patterns
        # https://stackoverflow.com/questions/44009040/replacing-all-overlapping-patterns-in-a-string/44009095#44009095
        content = re.sub(rf"(?<=[^a-zA-Z0-9_\'\"`]){kw}(?=[^a-zA-Z0-9_\'\"`])", kw, content, flags=re.I)
    return content.strip()


def patch(content, direction="out"):
    # some special case
    # [1] SET xxx=yyy;
    # [2] ADD JAR hdfs:///...jar;
    # [3] #set ($VARIABLE="xxxx")
    content = re.sub(
        r"set ([\w\.]+)=([\w\.]+);", lambda m: f"SET {m.group(1).lower()}={m.group(2).lower()};", content, flags=re.I
    )

    content = re.sub(r"#set", r"#set", content, flags=re.I)
    content = re.sub(r"\.jar", ".jar", content, flags=re.I)
    return content


def main():
    path = Path(args.file)
    if path.is_file():
        with path.open("r", encoding="utf-8") as f:
            content = f.read()

        content = patch(substitute(content))
        Console.info("Format success")
        print(content)
        if not args.inplace:
            new_name = f"{path.stem}_copy{path.suffix}"
            path = Path(path.parent, new_name)

        with path.open("w", encoding="utf-8") as f:
            f.write(content)
        Console.info(f"Save in '{path.as_posix()}' ☕️")
    else:
        Console.error(f"File '{path.as_posix()}' not exit")


if __name__ == "__main__":
    main()
